\documentclass[10pt]{article}
%\usepackage[left=2.3cm,right=2.3cm,top=2.5cm,bottom=3cm,a4paper]{geometry}
\usepackage{fullpage}
\usepackage{setspace}
\setstretch{1.3}
\usepackage{amsmath,amssymb,amsthm,physics,units,mathtools}
\usepackage[shortlabels]{enumitem}
\setlength\parindent{0pt}
\usepackage{float}
\usepackage{kotex}
\usepackage{multicol}
\usepackage{listings}
\usepackage{algorithm,algpseudocode}
\usepackage[shortlabels]{enumitem}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=black,
    filecolor=black,      
    urlcolor=black,
    pdftitle={Overleaf Example},
    pdfpagemode=FullScreen,
}
\NewDocumentCommand{\code}{v}{%
\texttt{#1}%
}

\begin{document}
\begin{center}
    {\LARGE 알고리즘 HW1} \\
    \vspace{3mm}
    공과대학 컴퓨터공학부 \\
    2021-16988 박재완
\end{center}

\section*{1번}
\begin{enumerate}[leftmargin=*, label=(\arabic*)]
    \item Master Thm을 이용하면, $a=4$, $b=4$, $f(n)=b$, $h(n)=n$이다. $\dfrac{f(n)}{h(n)} = \dfrac{b}{n} = O\qty(\dfrac{1}{n})$이므로, $T(n) = \Theta(n)$.
    \item $n = 3^k$라고 가정하자. 그러면 다음과 같다.
    \begin{align*}
        T(n) &= 3T\qty(\frac{n}{3}) + n\log{n} = 3T\qty(3^{k-1}) + 3^k\log{3^k} \\
        &= 3\qty(3T\qty(3^{k-2}) + 3^{k-1}\log{3^{k-1}}) + 3^k\log{3^k} = 3^2T\qty(3^{k-2}) + 3^k\qty(\log{3^k} + \log{3^{k-1}}) \\
        &= \cdots = 3^kT\qty(3^0) + 3^k\qty(\log{3^k} + \cdots + \log{3^1}) \\
        &= 3^kT(1) + \frac{\log{3}}{2}3^kk(k+1) = nT(1) + \frac{\log{3}}{2}n\log_3{n}(\log_3{n}+1)
    \end{align*}
    따라서 $T(n) = \Theta\qty(n\qty(\log{n})^2)$
    \item Master Thm을 이용하면, $a=5$, $b=5$, $f(n)=3n$, $h(n)=n$이다. $\dfrac{f(n)}{h(n)} = 3 = \Theta(1)$이므로, $T(n) = \Theta(n\log{n})$.
    \item 어떤 양의 상수 $c$가 존재하여 $k < n$인 모든 $k$에 대하여 $T(k) \leq ck\log{k}$을 만족한다고 가정하자. 그러면 충분히 큰 $n$에 대하여 다음이 성립한다.
    \begin{align*}
        T(n) &= T\qty(\frac{n}{4}) + T\qty(\frac{3n}{4}) + \Theta(n) \\
        &\leq \frac{cn}{4}\log\qty(\frac{n}{4}) + \frac{3cn}{4}\log\qty(\frac{3n}{4}) + \Theta(n) = \frac{cn}{4}\log\qty(\frac{n}{4}) + \frac{3cn}{4}\qty(\log{3} + \log\qty(\frac{n}{4})) + \Theta(n) \\
        &= cn\log\qty(\frac{n}{4}) + \frac{3\log{3}}{4}cn + \Theta(n) = cn\log{n} + \log{\frac{3^{\frac{3}{4}}}{4}}cn + \Theta(n) \\
        &\leq cn\log{n} + \log{\frac{3^{\frac{3}{4}}}{4}}cn + dn \;\; (\exists d > 0) \\
        &\leq cn\log{n} \;\; \qty(\qty(\frac{4}{3^{\frac{3}{4}}})^c > d\,\text{인 } c\,\text{에 대하여 성립})
    \end{align*}
    따라서 충분히 큰 모든 정수 $n$에 대하여 $T(n) \leq cn\log{n}$이 성립한다고 할 수 있다. 따라서 $T(n) = O(n\log{n})$.

    \vspace{2mm}
    어떤 양의 상수 $c$가 존재하여 $k < n$인 모든 $k$에 대하여 $T(k) \geq ck\log{k}$을 만족한다고 가정하자. 그러면 충분히 큰 $n$에 대하여 다음이 성립한다.
    \begin{align*}
        T(n) &= T\qty(\frac{n}{4}) + T\qty(\frac{3n}{4}) + \Theta(n) \\
        &\geq \frac{cn}{4}\log\qty(\frac{n}{4}) + \frac{3cn}{4}\log\qty(\frac{3n}{4}) + \Theta(n) = cn\log{n} + \log{\frac{3^{\frac{3}{4}}}{4}}cn + \Theta(n) \\
        &\geq cn\log{n} + \log{\frac{3^{\frac{3}{4}}}{4}}cn + dn \;\; (\exists d > 0) \\
        &\geq cn\log{n} \;\; \qty(\qty(\frac{4}{3^{\frac{3}{4}}})^c < d\,\text{인 } c\,\text{에 대하여 성립})
    \end{align*}
    따라서 충분히 큰 모든 정수 $n$에 대하여 $T(n) \geq cn\log{n}$이 성립한다고 할 수 있다. 따라서 $T(n) = \Omega(n\log{n})$.
    
    \vspace{2mm}
    종합적으로 $T(n) = \Theta(n\log{n})$이다.
    \item 어떤 양의 상수 $c$가 존재하여 $k < n$인 모든 $k$에 대하여 $T(k) \leq ck\log{k}$을 만족한다고 가정하자. 그러면 충분히 큰 $n$과 $c=5$에 대하여 다음이 성립한다.
    \begin{align*}
        T(n) &= 3T\qty(\frac{n}{3} + 9) + n \\
        &\leq 3c\qty(\frac{n}{3} + 9)\log\qty(\frac{n}{3} + 9) + n = c\qty(n + 27)\log\qty(\frac{n}{3} + 9) + n \\
        &\leq c(n+27)\log\frac{4n}{5} + n \\
        &= cn\log{n} + \qty(c\log{\frac{4}{5}} + 1)n + 27c\log\frac{4n}{5} \\
        &\leq cn\log{n}
    \end{align*}
    따라서 충분히 큰 모든 정수 $n$에 대하여 $T(n) \leq cn\log{n}$이 성립한다고 할 수 있다. 따라서 $T(n) = O(n\log{n})$.

    \vspace{2mm}
    어떤 양의 상수 $c$가 존재하여 $k < n$인 모든 $k$에 대하여 $T(k) \geq ck\log{k}$을 만족한다고 가정하자. 그러면 충분히 큰 $n$과 $c=1$에 대하여 다음이 성립한다.
    \begin{align*}
        T(n) &= 3T\qty(\frac{n}{3} + 9) + n \\
        &\geq 3c\qty(\frac{n}{3} + 9)\log\qty(\frac{n}{3} + 9) + n = c\qty(n + 27)\log\qty(\frac{n}{3} + 9) + n \\
        &\geq c(n+27)\log\frac{n}{3} + n \\
        &= cn\log{n} + \qty(c\log{\frac{1}{3}} + 1)n + 27c\log\frac{n}{3} \\
        &\geq cn\log{n}
    \end{align*}
    따라서 충분히 큰 모든 정수 $n$에 대하여 $T(n) \geq cn\log{n}$이 성립한다고 할 수 있다. 따라서 $T(n) = \Omega(n\log{n})$.
    
    \vspace{2mm}
    종합적으로 $T(n) = \Theta(n\log{n})$이다.
\end{enumerate}

\section*{2번}

함수 \code{sample(A[], p, r)}의 실행시간을 $T(p, r)$이라 하자. 
그러면 $r-p > 3$인 경우, \code{if} 블럭에서 1번의 비교, \code{for} 블럭에서 $(r-p+1)$번의 비교를 하게 된다. 
이후 \code{sample(A[], p, p+q-1)}, \code{sample(A[], p+2q, r)}을 실행한다. 따라서 실행시간은 다음과 같다.
\begin{align*}
    T(p, r) &= 1 + (r-p+1) + T\qty(p, p + \left\lfloor\frac{r-p+1}{4}\right\rfloor - 1) + T\qty(p + 2\left\lfloor\frac{r-p+1}{4}\right\rfloor, r) \\
    &= r-p+2 + T\qty(p, p + \left\lfloor\frac{r-p+1}{4}\right\rfloor - 1) + T\qty(p + 2\left\lfloor\frac{r-p+1}{4}\right\rfloor, r)
\end{align*}
어떤 양의 상수 $c$가 존재하여 $r'-p'+1 < r-p+1$인 모든 $p'$, $r'$에 대하여 $T(p', r') \leq c\qty(r'-p'+1)$을 만족한다고 가정하자. 그러면 $(r-p+1)$이 충분히 클 때, 다음이 성립한다.
\begin{align*}
    T(p, r) &= r-p+2 + T\qty(p, p + \left\lfloor\frac{r-p+1}{4}\right\rfloor - 1) + T\qty(p + 2\left\lfloor\frac{r-p+1}{4}\right\rfloor, r) \\
    &\leq r-p+2 + c\left\lfloor\frac{r-p+1}{4}\right\rfloor + c\qty(r-p+1 - 2\left\lfloor\frac{r-p+1}{4}\right\rfloor) \\
    &= (c+1)(r-p+1) - c\left\lfloor\frac{r-p+1}{4}\right\rfloor + 1 \\
    &= c(r-p+1) + \qty((r-p+1) - c\left\lfloor\frac{r-p+1}{4}\right\rfloor + 1) \\
    &\leq c(r-p+1)
\end{align*}
$r-p+1 \geq 4$일 때, $c = 8$을 선택해주면 $(r-p+1) - c\left\lfloor\dfrac{r-p+1}{4}\right\rfloor + 1 \leq 0$이 되어 위 관계가 성립한다. 따라서 충분히 큰 $(r-p+1)$에 대하여 $T(p, r) \leq c(r-p+1)$이 성립한다고 할 수 있다. 따라서 $T(p, r) = O(r-p)$.

\vspace{3mm}
어떤 양의 상수 $c$가 존재하여 $r'-p'+1 < r-p+1$인 모든 $p'$, $r'$에 대하여 $T(p', r') \geq c\qty(r'-p'+1)$을 만족한다고 가정하자. 그러면 $(r-p+1)$이 충분히 클 때, 다음이 성립한다.
\begin{align*}
    T(p, r) &= r-p+2 + T\qty(p, p + \left\lfloor\frac{r-p+1}{4}\right\rfloor - 1) + T\qty(p + 2\left\lfloor\frac{r-p+1}{4}\right\rfloor, r) \\
    &\geq r-p+2 + c\left\lfloor\frac{r-p+1}{4}\right\rfloor + c\qty(r-p+1 - 2\left\lfloor\frac{r-p+1}{4}\right\rfloor) \\
    &= c(r-p+1) + \qty((r-p+1) - c\left\lfloor\frac{r-p+1}{4}\right\rfloor + 1) \\
    &\geq c(r-p+1)
\end{align*}
$c = 1$을 선택해주면 $(r-p+1) - c\left\lfloor\dfrac{r-p+1}{4}\right\rfloor + 1 \geq 0$이 되어 위 관계가 성립한다. 따라서 $(r-p+1)$이 충분히 큰 모든 $p$, $r$에 대하여 $T(p, r) \geq c(r-p+1)$이 성립한다고 할 수 있다. 따라서 $T(p, r) = \Omega(r-p)$.

\vspace{3mm}
종합적으로 $T(p, r) = \Theta(r-p)$이다.

\section*{3번}
함수 \code{test(n)}의 실행시간을 $T(n)$이라 하자.
그러면 \code{if} 블럭에서 1번의 비교를 하게 되고, $n>50$인 경우 \code{test(n/3 + 5)}와 \code{test(2n/3 + 7)}을 실행한다. 
따라서 실행시간은 다음과 같다.
$$T(n) = 1 + T\qty(\frac{n}{3}+5) + T\qty(\frac{2n}{3}+7)$$
어떤 양의 상수 $c$가 존재하여 $k<n$인 모든 $k$에 대하여 $T(k) \leq ck - 2$을 만족한다고 가정하자. 그러면 $n$이 충분히 클 때, 다음이 성립한다.
\begin{align*}
    T(n) &= 1 + T\qty(\frac{n}{3}+5) + T\qty(\frac{2n}{3}+7) \\
    &\leq 1 + c\qty(\frac{n}{3}+5) - 2 + c\qty(\frac{2n}{3}+7) - 2 \\
    &= cn + 12c - 3 \\
    &\leq cn - 2
\end{align*}
$c = \dfrac{1}{12}$을 선택해주면 $12c-3 = -2$가 되어 위 관계가 성립한다. 
따라서 충분히 큰 모든 $n$에 대하여 $T(n) \leq cn-2$이 성립한다고 할 수 있다. 따라서 $T(n) = O(n)$.

\section*{4번}
길이가 1인 배열에 대하여 selection sort 알고리즘이 성공적으로 sorting을 함은 자명하다. 
길이가 $n$인 배열에 대하여 알고리즘이 성공적인 sorting을 한다고 가정하자. 
재귀적 selection sort 알고리즘은 우선 $n > 1$임을 확인하고, \code{A[0]}, $\cdots$, \code{A[n]} 중 최댓값을 찾아 \code{A[last]}와 교환한다.
이후 \code{A[0 : n-1]}에 대하여 재귀적으로 selection sort를 호출한다. 이때 이는 크기가 $n$인 배열이므로, 정렬이 성공적으로 수행된다.
$0$번째부터 $(n-1)$번째 원소까지 성공적으로 정렬되어있고, $n$번째 자리에 배열 전체의 최댓값이 위치해 있으므로, 크기가 $(n+1)$인 이 경우에도 정렬은 성공적으로 된다고 할 수 있다.
따라서 수학적 귀납법에 의하여 selection sort 알고리즘은 언제나 성공적인 sorting을 한다고 할 수 있다.

\section*{5번}
Quicksort의 worst case는 pivot이 항상 최댓값 혹은 최솟값으로 선택되는 경우에 발생한다. 
Pivot을 중간값으로 선택하는 경우 원하는 정렬을 할 수 있다. 
아래 알고리즘을 통하여 $\Theta(n)$의 시간 안에 크기가 $n$인 배열의 중간값의 인덱스을 찾을 수 있다.

\vspace{3mm}
정확히는 배열의 원소 중 $i$번째로 작은 원소를 찾는 것인데, 배열을 크기가 5인 배열들로 나누어 각각의 중간값을 구한 뒤, 그 값들의 배열을 다시 크기 5인 배열들로 나누어 각각의 중간값을 구하는 과정을 반복하여 적절한 pivot을 찾는다.
이 pivot은 전체 배열의 중간값에 가까운 값으로 선택될 것이다. 이를 기준으로 배열을 partition한 뒤, $i$ 번째 원소가 포함되어 있는 쪽을 선택하여 이 전체 과정을 재귀적으로 반복하여 원하는 값을 찾을 수 있다.
\begin{algorithm}[H]
\caption{5번 - 1}\label{findmedian}
\begin{algorithmic}
    \Procedure{FindIthIndex}{$A[]$, $p$, $r$, $i$} \Comment{Find the index of the $i$th smallest element in $A[p, \cdots, r]$}
        \If{$r-p+1 < 5$}
            \State \textbf{return} median index of $A$
        \EndIf
        \State $M[] \gets$ $\Big[$$A\Big[$\textsc{FindIthIndex}($A$, $p$, $p+4$, $3$)$\Big]$, $\cdots$, $A\Big[$\textsc{FindIthIndex}($A$, $r-4$, $r$, $3$)$\Big]$$\Big]$
        \State $pivotIndex \gets$ \textsc{FindIthIndex}$\qty(M, \;1, \;\dfrac{r-p+1}{5}, \;\dfrac{r-p+1}{10})$
        \State $q \gets$ \textsc{Partition}($A$, $p$, $r$, $pivotIndex$)
        \If{$q-p \geq i$}
            \State \textbf{return} \textsc{FindIthIndex}($A$, $p$, $q-1$, $i$)
        \Else
            \State \textbf{return} \textsc{FindIthIndex}($A$, $q$, $r$, $i-q+p$)
        \EndIf
    \EndProcedure
    \Procedure{Partition}{$A[]$, $p$, $r$, $pivotIndex$} \Comment{Relocate elements and return pivot index}
        \State Relocate elements of $A[p, \cdots, r]$ using $A[pivotIndex]$ as the pivot.
        \State \textbf{return} final index of the pivot
    \EndProcedure
\end{algorithmic}
\end{algorithm}
전체 배열의 크기를 $n$이라 하자.
크기가 5인 배열의 중간값을 구하는 과정은 각각 $\Theta(1)$의 시간을 소요하고, 총 $\dfrac{n}{5}$번 반복하므로 $\Theta(n)$의 시간이 소요된다.
이를 대상으로 다시 중간값을 구하는 과정에는 \code{FindIthIndex()}가 다시 호출되므로 $T\qty(\dfrac{n}{5})$의 시간이 소요된다.
\code{Partition()}은 배열의 전 원소를 pivot과 한번씩 비교하므로 실행시간이 $\Theta(n)$이다. 
이때 선택된 pivot은 중간값들의 중간값이므로, worst case에서 분할을 $\dfrac{3n}{10}$, $\dfrac{7n}{10}$의 크기로 하고, 재귀 단계에서 최대 $T\qty(\dfrac{7n}{10})$의 시간을 소요한다.
크기가 $n$인 배열에 대하여 \code{FindIthIndex()}의 전체 실행 시간을 $T_I(n)$이라 하면, 복잡도는 다음과 같다.
편의상 $n = 5^k$라 가정한다.
\begin{align*}
    T_I(n) &\leq \Theta(n) + T_I\qty(\frac{n}{5}) + \Theta(n) + T_I\qty(\frac{7n}{10}) = T_I\qty(\frac{n}{5}) + T_I\qty(\frac{7n}{10}) + \Theta(n)
\end{align*}
어떤 양의 상수 $c$가 존재하여 $k < n$인 모든 $k$에 대하여 $T_I(k) \leq ck$을 만족한다고 가정하자. 그러면 충분히 큰 $n$에 대하여 다음이 성립한다.
\begin{align*}
    T_I(n) &\leq T_I\qty(\frac{n}{5}) + T_I\qty(\frac{7n}{10}) + \Theta(n) \\
    &\leq \frac{cn}{5} + \frac{7cn}{10} + \Theta(n) = cn - \frac{cn}{10} + \Theta(n) \\
    &\leq cn - \frac{cn}{10} + dn \; (\exists d > 0) \\
    &\leq cn
\end{align*}
$c \geq 10d$로 선택해주면 $-\dfrac{cn}{10} + dn < 0$이 되어 위 관계가 성립한다. 따라서 충분히 큰 모든 정수 $n$에 대하여 $T(n) \leq cn$이 성립한다고 할 수 있다. 따라서 $T_I(n) = O(n)$.

\vspace{3mm}
따라서 전체 quicksort은 다음과 같이 개선할 수 있다.
\begin{algorithm}[H]
\caption{5번 - 2}\label{quicksort}
\begin{algorithmic}
    \Procedure{EnhancedQuicksort}{$A[]$, $p$, $r$} \Comment{Sort $A[p, \cdots, r]$}
        \If{$p < r$}
            \State $pivotIndex \gets$ \textsc{FindIthIndex}$\qty(A, \;p, \;r, \;\left\lceil\dfrac{r-p+1}{2}\right\rceil)$
            \State $q \gets$ \textsc{Partition}($A$, $p$, $r$, $pivotIndex$)
            \State \textsc{EnhancedQuicksort}($A$, $p$, $q-1$)
            \State \textsc{EnhancedQuicksort}($A$, $q+1$, $r$)
        \EndIf
    \EndProcedure
\end{algorithmic}
\end{algorithm}
매 sorting 과정마다 pivot이 중간값으로 선택된다. 
크기가 $n$인 배열에 대하여 이 알고리즘의 실행 시간을 $T(n)$이라 한다면 다음과 같이 계산된다.
편의상 $n=2^k$라 가정한다.
\begin{align*}
    T(n) &= O(n) + \Theta(n) + 2T\qty(\frac{n}{2}) = 2O\qty(2^k) + 2T\qty(2^{k-1})\\
    &= 2O\qty(2^k) + 2\qty(2O\qty(2^{k-1}) + 2T\qty(2^{k-2})) = 2O\qty(2^k) + 2^2O\qty(2^{k-1}) + 2^2T\qty(2^{k-2}) \\
    &= \cdots = 2O\qty(2^k) + \cdots + 2^{k-1}O\qty(2^2) + 2^{k-1}T(2) \\
    &= (k-1)O\qty(2^{k+1}) + O\qty(2^k) \\
    &= O\qty(k2^k) = O(n\log{n})
\end{align*}
따라서 총 알고리즘의 시간복잡도가 $O(n\log{n})$으로, worst case에서도 유지된다.

\section*{6번}
\begin{algorithm}[H]
\caption{6번}\label{mergesort}
\begin{algorithmic}
    \Procedure{EnhancedMergesort}{$A[]$, $p$, $r$} \Comment{Sort $A[p, \cdots, r]$}
        \If{$p < r$}
            \State $q_1, q_2, \cdots , q_{15} \gets \left\lfloor\frac{15p+r}{16}\right\rfloor, \left\lfloor\frac{14p+2r}{16}\right\rfloor, \cdots , \left\lfloor\frac{p+15r}{16}\right\rfloor$
            \State \textsc{EnhancedMergesort}($A$, $p$, $q_1$)
            \State \textsc{EnhancedMergesort}($A$, $q_1$+1, $q_2$)
            \State $\;\;\;\;\;\;\; \vdots$
            \State \textsc{EnhancedMergesort}($A$, $q_{15}+1$, $r$)
            \State \textsc{Merge}($A$, $p$, $q_1$, $q_2$, $\cdots$, $q_{15}$, $r$)
        \EndIf
    \EndProcedure
    \Procedure{Merge}{$A[]$, $p$, $q_1$, $q_2$, $\cdots$, $q_{15}$, $r$} \Comment{Merge 16 sorted arrays}
        \State $o \gets$ empty array of size $r-p+1$
        \State $h \gets$ min-heap made of the first elements of $A[p, \cdots, q_1]$, $A[q_1+1, \cdots, q_2]$, $\cdots$, $A[q_{15}+1, \cdots, r]$
        \While{$h$ is not empty}
            \State Delete the minimum element of $h$ and insert it to $o$.
            \If{the array from which the deleted element came from is not empty}
                \State Insert the next element of the array to $h$.
            \EndIf
        \EndWhile
        \EndProcedure
\end{algorithmic}
\end{algorithm}
배열의 길이가 $n$일 때 실행시간을 $T(n)$이라 하자. 이때 $T(1) = 1$이다.

\vspace{3mm}
\code{Merge()}는 크기가 16인 힙을 만드는 과정, 힙에 $(n-16)$개의 원소를 추가하는 과정, 그리고 최상위 원소를 $n$번 순차적으로 삭제하는 과정을 포함한다.
이때 일반적으로 크기가 $m$인 힙에서 \code{buildHeap()}의 실행시간은 $\Theta(m)$, \code{insert()}의 실행시간은 $O(\log{m})$, \code{deleteMin()}의 실행시간은 $O(\log{m})$이다.
매 순간 힙의 크기는 $16$을 넘지 않는다. 따라서 총 실행시간은 힙 만들기에 $\Theta(16) = \Theta(1)$, 원소 추가에 최대 $O(\log{16}) \times (n-16) = O(n)$, 최솟값 삭제에 최대 $O(\log{16}) \times n = O(n)$이고, 총 \code{Merge()} 실행시간은 $O(n)$라 할 수 있다.

\vspace{3mm}
따라서 $n = 16^k$이라 가정할 떄, 전체 실행시간은 다음과 같다.
\begin{align*}
    T(n) &= 16T\qty(\frac{n}{16}) + O(n) \\
    &= 16\qty(16T\qty(\frac{n}{16^2}) + O\qty(\frac{n}{16})) + O(n) = 16^2T\qty(\frac{n}{16^2}) + 2O(n) \\
    &= 16^3T\qty(\frac{n}{16^3}) + 3O(n) = \cdots = 16^kT\qty(1) + kO(n) \\
    &= n + O(n\log{n}) = O(n\log{n})
\end{align*}

\section*{7번}
\begin{enumerate}[leftmargin=*, label=(\arabic*)]
    \item 한 번의 \code{mergeSort()} 호출에서 재귀 부분을 제외하고 한 번씩 \code{merge()}가 호출되므로, 하나의 \code{tmp[]} 배열이 생성된다.
    배열의 분할은 크기가 1인 배열이 될 때까지 이루어지므로, $n=2^k$라고 가정하면 \code{merge()}의 총 호출 횟수는 $1 + 2 + 2^2 + \cdots + 2^k = 2^{k+1} - 1 = 2n - 1$회이다.
    따라서 \code{tmp[]} 배열 역시 약 $2n-1 = \Theta(n)$개 생성된다. 
    \item 각 \code{merge()} 단계에서 생성되는 \code{tmp[]} 배열의 크기는 $(r-p+1)$이다. 
    $n=2^k$라고 가정하면, 호출되는 \code{merge()}에서 배열의 크기는 $2^k$인 경우 1번, $2^{k-1}$인 경우 2번, $\cdots$, $1$인 경우 $2^k$번 등장한다.
    따라서 모든 \code{tmp[]} 배열들의 크기의 합은 다음과 같다.
    \begin{align*}
        \text{Sum} &= 2^k \times 1 + 2^{k-1} \times 2 + \cdots + 1 \times 2^k \\
        &= (k+1)2^k = \\
        &= \Theta\qty(k2^k) = \Theta\qty(n\log{n})
    \end{align*}
\end{enumerate}

\end{document}